---
title: "3.5 Modeling : Logistic Regression"
author: "Himanshu"
date: "April 10, 2019"
output: html_document
---
```{r}
library(dplyr)
library(caret)
library(lubridate)
library(stringr)
library(tidyr)
library(corrplot)
library(ggcorrplot)
library(leaps)
library(MASS)
library(ggplot2)
library(standardize)
library(Amelia)
library(ROCR)
```

```{r}
df <- read.csv("TransfromedData1.csv", header = TRUE)
summary(df)
#table(df$YearBefore)
```
```{r}
df <-
  df %>%
  mutate(default = ifelse(!(loan_status %in% "Defaulted"), FALSE, TRUE))
table(df$default)
df %>%
  summarise(default_freq = sum(default / n()))
table(df$default) / nrow(df)
```


```{r}
vars_to_remove <- c("X.1", "X","YearBefore","addr_state", "issue_d", "earliest_cr_line", "GeoName", "loan_status")

df1 <- df[, ! names(df) %in% vars_to_remove, drop = F]
str(df1)
```

```{r}
# We'll do stratified sampling to split our data into training and test sets

targetVar <- 'default'
inTrain <- createDataPartition(y = df1[,targetVar], list = FALSE, p = .8)
train <- df1[inTrain,]
test <- df1[-inTrain,]
stopifnot(nrow(train) + nrow(test) == nrow(df1))
names(df1)
```

```{r}
xVars <- c("loan_amnt", "term", "int_rate", "installment", "grade",
           "home_ownership", "annual_inc", "verification_status","pymnt_plan", "purpose",
           "dti", "open_acc", "pub_rec", "total_acc", "initial_list_status", 
           "Compensation.of.employees", "Gross.operating.surplus", "Per.capita.real.GDP.by.state", 
           "Quantity.indexes.for.real.GDP.by.state", "Real.GDP.by.state", "Subsidies", 
           "Taxes.on.production.and.imports", "regions", "month" )
```

```{r}
# Imbalanced data - under-sampling
train_down <- 
  caret::downSample(x = train[, xVars], 
                    y = as.factor(train$default), yname = "default")

base::prop.table(table(train_down$default))
base::table(train_down$default)
```




```{r}
# Formula Function

createModelFormula <- function(targetVar, xVars, includeIntercept = TRUE){
  if(includeIntercept){
    modelForm <- as.formula(paste(targetVar, "~", paste(xVars, collapse = '+ ')))
  } else {
    modelForm <- as.formula(paste(targetVar, "~", paste(xVars, collapse = '+ '), -1))
  }
  return(modelForm)
}


```

```{r}
# Building model with all variables
modelForm <- createModelFormula(targetVar, xVars, includeIntercept = T)

full_model <- glm(modelForm,family=binomial(link='logit'),data=train_down)

summary(full_model)

```

```{r}
full_model_Pred <- 
  predict.glm(object = full_model, newdata = test, type = "response")
model_pred_t<- unname(ifelse(full_model_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default)) 

# Let's look at the ROC curve
pr <- prediction(full_model_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc

```

```{r}
varImp(full_model)

```
```{r}
# Building model for VarImp variables

test_model <- glm(default~int_rate+grade+annual_inc+purpose+pub_rec+initial_list_status+Quantity.indexes.for.real.GDP.by.state+Real.GDP.by.state+month+Taxes.on.production.and.imports-1,family=binomial(link='logit'), data=train_down, na.action = na.exclude)

x <- c("int_rate","grade","annual_inc","purpose","pub_rec","initial_list_status","Quantity.indexes.for.real.GDP.by.state","Real.GDP.by.state","month", "Taxes.on.production.and.imports")

test_model_Pred <- 
  predict.glm(object = test_model, newdata = test, type = "response")
model_pred_t<- unname(ifelse(test_model_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))

# Let's look at the ROC curve
pr <- prediction(test_model_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc


```

```{r}
# Building model with No variables
model_Null <- glm(default ~ 1,family=binomial(link='logit'),data=train_down)
summary(model_Null)

Model_forward <- stepAIC(model_Null, direction = "forward", scope=list(upper=full_model,lower=model_Null))
```


```{r}
model1 <- glm(default ~ Per.capita.real.GDP.by.state, family=binomial(link='logit'),data=train_down)
summary(model1)
x <- c("Per.capita.real.GDP.by.state")

model1_Pred <- 
  predict.glm(object = model1, newdata = test, type = "response")
model_pred_t<- unname(ifelse(model1_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(model1_Pred)

# Let's look at the ROC curve
pr <- prediction(model1_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc


#this looks really bad model
```

```{r}
Model_backward <- stepAIC(full_model, direction = "backward")

```
```{r}

model2 <- glm(default ~ term+Per.capita.real.GDP.by.state+Real.GDP.by.state, family=binomial(link='logit'),data=train_down)
summary(model2)
x2 <- c( "term",
           "Per.capita.real.GDP.by.state", 
           "Real.GDP.by.state")

model2_Pred <- 
  predict.glm(object = model2, newdata = test, type = "response")
model_pred_t<- unname(ifelse(model2_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(model2_Pred)

# Let's look at the ROC curve
pr <- prediction(model2_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc



```

```{r}
Model_Step <- stepAIC(full_model, direction = "both" )
```

```{r}
model3 <- glm(default ~ term+Per.capita.real.GDP.by.state, family=binomial(link='logit'),data=train_down)
summary(model3)
x3 <- c( "term",
           "Per.capita.real.GDP.by.state")

model3_Pred <- 
  predict.glm(object = model3, newdata = test, type = "response")
model_pred_t<- unname(ifelse(model3_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(model3_Pred)

# Let's look at the ROC curve

pr <- prediction(model3_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc

```

```{r}
library(earth)
marsModel <- earth(default ~ ., data=train_down) # build model
ev <- evimp (marsModel)
ev
```
```{r}
model4 <- glm(default ~ int_rate+Quantity.indexes.for.real.GDP.by.state+month+annual_inc+initial_list_status+Real.GDP.by.state+Per.capita.real.GDP.by.state+Compensation.of.employees+Gross.operating.surplus+regions+Subsidies+Taxes.on.production.and.imports+dti, family=binomial(link='logit'), data=train_down)

summary(model4)

x3 <- c("int_rate","Quantity.indexes.for.real.GDP.by.state","month","annual_inc","initial_list_status","Real.GDP.by.state","Per.capita.real.GDP.by.state","Compensation.of.employees","Gross.operating.surplus","regions","Subsidies","Taxes.on.production.and.imports","dti")

model4_Pred <- 
  predict.glm(object = model4, newdata = test, type = "response")
model_pred_t<- unname(ifelse(model3_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(model4_Pred)
```

```{r}
# Let's look at the ROC curve
library(ROCR)
pr <- prediction(model4_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc
```

```{r}
# Let's look at the precision recall curves
# install.packages('DMwR')
library('DMwR')
PRcurve(preds = model4_Pred, trues = test$default)

# Let's take a look at the deviance
llcomponents <- function(y, predicted.y){
  return(y*log(predicted.y) + (1-y)*log(1-predicted.y))
}
y <- train_down[,targetVar]
predicted.y <- predict(model4
                       ,newdata = train_down[,x3]
                       # Specifying response means we want the probabilities
                       ,type='response')

deviance <- sign(as.numeric(y) - predicted.y)*sqrt(-2*llcomponents(as.numeric(y), predicted.y))

summary(deviance)
```

```{r}
# Primary data model 
xPrimary <- c("loan_amnt", "term", "int_rate", "installment", "grade",
           "home_ownership", "annual_inc", "verification_status","pymnt_plan", "purpose",
           "dti", "open_acc", "pub_rec", "total_acc", "initial_list_status", 
           "regions", "month" )

modelForm <- createModelFormula(targetVar, xPrimary, includeIntercept = T)

Primary_model <- glm(modelForm,family=binomial(link='logit'),data=train_down)

summary(Primary_model)

Primary_model_Pred <- 
  predict.glm(object = Primary_model, newdata = test, type = "response")
model_pred_t<- unname(ifelse(Primary_model_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(Primary_model_Pred)

# Let's look at the ROC curve
pr <- prediction(Primary_model_Pred, test$default)
prf <- performance(pr, measure = "tpr", x.measure = "fpr")
plot(prf)

auc <- performance(pr, measure = "auc")
auc <- auc@y.values[[1]]
auc

```

```{r}
library(party)
cf1 <- cforest(default ~ . , data= train_down, control=cforest_unbiased(mtry=2,ntree=50))
cf1
```
```{r}
model5 <- glm(default ~ loan_amnt+ term+ int_rate+ installment+ grade+ home_ownership+ annual_inc+ verification_status+ pymnt_plan+ purpose+ dti+ open_acc+ pub_rec+ total_acc+ initial_list_status+ Compensation.of.employees+ Gross.operating.surplus+ Per.capita.real.GDP.by.state+ Quantity.indexes.for.real.GDP.by.state+ Real.GDP.by.state+ Subsidies+ Taxes.on.production.and.imports+ regions+ month , family=binomial(link='logit'), data=train_down)

summary(model5)

model5_Pred <- 
  predict.glm(object = model5, newdata = test, type = "response")
model_pred_t<- unname(ifelse(model5_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(model5_Pred)
```
```{r}
#leaps (regression subset selection)
require(leaps)
require(MASS)
regsubsets.out <- regsubsets(default ~ loan_amnt+ term+ int_rate+ installment+ grade+ home_ownership+ annual_inc+ verification_status+ pymnt_plan+ purpose+ dti+ open_acc+ pub_rec+ total_acc+ initial_list_status+ Compensation.of.employees+ Gross.operating.surplus+ Per.capita.real.GDP.by.state+ Quantity.indexes.for.real.GDP.by.state+ Real.GDP.by.state+ Subsidies+ Taxes.on.production.and.imports+ regions+ month, data=train_down, nbest= 1, method= "exhaustive")
summary(regsubsets.out)

#Best model at each variable number
summary.out <- summary(regsubsets.out)
as.data.frame(summary.out$outmat)
```
```{r}
## Adjusted R2
plot(regsubsets.out, scale = "adjr2", main = "Adjusted R^2")
```


```{r}
library(car)
layout(matrix(1:1, ncol = 1))
## Adjusted R2
## This is just another way of presenting the same information for adjusted \( R^2 \)
res.legend <-
    subsets(regsubsets.out, statistic="adjr2", legend = FALSE, min.size = 5, main = "Adjusted R^2")
## Mallow Cp
## Mallow Cp is used to decide on the number of predictors to include. 
res.legend <-
    subsets(regsubsets.out, statistic="cp", legend = FALSE, min.size = 5, main = "Mallow Cp")
abline(a = 1, b = 1, lty = 2)
res.legend
```
```{r}
## See which model has the highest adjusted R2
which.max(summary.out$adjr2)
```

```{r}
summary.out$which[8,]
```
```{r}
#building model with our best variables
final_model <- glm(default ~ term+pub_rec+initial_list_status+Quantity.indexes.for.real.GDP.by.state+ int_rate+
                     annual_inc+ Real.GDP.by.state+ month, family=binomial(link='logit'), data=train_down)

summary(final_model)

#x3 <- c("int_rate","Quantity.indexes.for.real.GDP.by.state","month","annual_inc","initial_list_status","Real.GDP.by.state","Per.capita.real.GDP.by.state","Compensation.of.employees","Gross.operating.surplus","regions","Subsidies","Taxes.on.production.and.imports","dti")

final_model_Pred <- 
  predict.glm(object = final_model, newdata = test, type = "response")
model_pred_t<- unname(ifelse(final_model_Pred > .5, TRUE, FALSE))
test[,'model_pred_t'] <- model_pred_t

confusionMatrix(table(test$model_pred_t, test$default))
hist(final_model_Pred)

# Pseudo-R**2
nullmod <- glm(default~1, family="binomial", data = train_down)
1-logLik(final_model)/logLik(nullmod)
```
















